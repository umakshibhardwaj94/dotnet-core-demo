SOLID :

---------------------------------------- SRP ------------------------------------------------------
Practice PDD(Pain Driven Dev)

s: Each software should hv only 1 reason to change.

What is Responsibility?
Class should have:
>>Persistence
>>Logging
>>Validation
>>Business Logic

Tight Coupling can cause a class difficult to chnge.
Loosely Coupled : less dependent on each other and easy to modify.
>>Cohesion :class elemnts that belongs together are cohesive.
A class in which the methods don't use data of each other i.e: less cohesive.
or behaivour with one another.

Coupling : Its b/w 2 classes.


Responsibities and testibility:

Responsibilities have direct relation to testibility.
Tests become:
>Longer
>More Complex
>Brittle
>Coupled to implementation.

-> By applying SRP now rather then having implementation class methods delegates behaviour by using other class methods

-> SRP strive for high cohesion (dependent methods/behaviour should be together) and loose coupling (between two or more classes)

-> Keep classes small, focused, and testable

------------------------------------------- Open/ Closed Principle --------------------------------------------------------------
-> Software entites (classes, modules, functions etc.) should be open for extension, but closed for modification.

-> It should be possible to change the behaviour of a method without editing its source code.

-> Open to extension
	- New behaviour can be added in the future
	- Code that is closed to extension has fixed behaviour
-> Closed to modification
	- Changes to source or binary code are not required
	- The only way to change the behaviour of code that is closed to the extension is to change the code itself

-> Why should code be closed to the modification?
	- Less likely to introduce bugs in code we don't touch or redeploy
	- Fewer conditionals in code that is ooen to extension result in simpler code
-> Balance abstraction and concreteness

-> Abstraction adds complexity

-> How can you predict future changes?
	- Start concrete (method should do only one thing)
	- Modify the code the first time or two
	- By the third modification, consider making the code open to extension for that axis of change
-> Typical approaches to OCP?
	- Parameters : by pass parameters to functions/methods we can change behaviour
	- Inheritance : Many design patterns leverage facilicitate to diffrent type of inheritance, simple add new child with existing features
	  	(by making parent method as virtual and override in child classes to change behaviour)
	- Composition/Injection : By adding dependency injection we can change behaviour without changing code
	- Extension methods - By creating concrete extension methods

-> Perfer implementing new features in new classes
	- Design class to suit problem at hand
	- Nothing in current system depends on it
	- Can add behaviour without touching exiting code
	- Can follow SRP
	- Can be unit tested

-> Packages and Libraries follows OCP
	-> Closed for modification
		- consumer cannot changes package contents
	-> Closed for modification in other sense
		- Should not break consumers when new behaviour is added
	-> Open to extension
		- Consumer should be able to extend the package to suit their own needs

------------------------------------------- Liskov Substitution Principle --------------------------------------------------------------
-> Subtypes must be substitutable for their base types

-> Ensure base type invariants are enforces (means your all methods should be implemented)

-> Basic Object Oriented Design
	- Something IS-A something else
		- An eagle IS-A bird
	- Something HAS-A property
		- An address HAS-A city

-> LSP states that IS-A relationship is insufficient and should be replaced with IS-SUBSTITUTABLE-FOR

-> Detecting LSP voilatios in Your code?
	- If you are checking type with 'is' or 'as' in polymorhic code (means it should work with type or any subtype)
	- Null checks
	- NotImplementedException
-> LSP is a Subset of Polymorphism
	- Polymorphism IS-A relationship and LSP IS-SUBSTITUTABLE 

-> Tell, Don't ASk means:
	Data & Logic seperate vs Data and logic together
For ex we have Print Report class which has method PrintEmployee and PrintManager, so every time when employee comes, Report class check its type and on the basis
 it print report.
- Rather then Asking everytime, Tell to print report to Manager and Employee by adding print method in employee and manager class

------------------------------------------- Interface Segregation Principle --------------------------------------------------------------
-> Clients should not forced to depend on methods they don't use

-> Violating ISP results in classes that depend on things they don't need

-> Large interfeces means more dependencies mean more coupling

- More birttle code

-> Detecting ISP violations in your code?
	- Large interfaces
	- NotImplementedExceptions
	- Code uses just a small subset of a larger interface

-> By using multiple interfaces, create small small interfaces with cohesive functionality and add it to parent

-> Probably use Adapter pattern to solve this problem

-> ISP is related to LSP (there should not be any notimplementedexception) and highly dependent on Cohesion and SRP

-> Fixing ISP violations
	- Break up large interfaces into smaller ones (componse fat interfaces from smaller ones for backward compatibility)
	- To address large interface you don't control
		- Create a small, cohesive interface
		- Use the Adapter design pattern so your code can work with the Adapter
-> Prefer small, cohesive interfaces to large, expansive ones
-> Following ISP helps with SRP and LSP
-> Breakup large interfaces by using 
	- Interface inheritance
	- The Adapter design pattern


<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:mes="http://xpsystems.com/services/apex/messages" xmlns:typ="http://xpsystems.com/services/apex/types">
   <soap:Header/>
   <soap:Body>
      <mes:PlasticCardUpdateRequest>
         <!--Optional:-->
         <mes:CardBin>434343</mes:CardBin>
         <!--Optional:-->
         <mes:CardCust>254174</mes:CardCust>
         <mes:MemberId>8934</mes:MemberId>
         <mes:PurchaseAccount>141</mes:PurchaseAccount>
       
      </mes:PlasticCardUpdateRequest>
   </soap:Body>
</soap:Envelope>